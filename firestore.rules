rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /questions/{questionId} {
      
      // 읽기 권한: 인증된 사용자 중 질문자 또는 담당자만 가능, 또는 완료된 질문은 모두 읽기 가능
      allow read: if request.auth != null && 
                     (resource.data.questioner == request.auth.uid || 
                      resource.data.assignee == request.auth.uid ||
                      resource.data.completed == true);
      
      // 생성 권한: 인증된 사용자만 가능
      allow create: if request.auth != null &&
                       request.resource.data.questioner == request.auth.uid &&
                       request.resource.data.keys().hasAll(['title', 'questioner', 'content', 'createdAt', 'updatedAt', 'completed']) &&
                       request.resource.data.title is string &&
                       request.resource.data.content is string &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       request.resource.data.completed is bool &&
                       (!request.resource.data.keys().hasAny(['answers']) || 
                        request.resource.data.answers is list);
        
      // 업데이트 권한: 질문자는 질문 수정 및 메시지 추가, 담당자는 답변 추가 가능
      allow update: if request.auth != null &&
                       // 공통 검증: createdAt과 questioner는 변경 불가
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.questioner == resource.data.questioner &&
                       // updatedAt은 항상 timestamp여야 함
                       request.resource.data.updatedAt is timestamp &&
                       // completed는 bool이어야 함
                       (request.resource.data.completed is bool) &&
                       (
                         // 질문자 권한
                         (resource.data.questioner == request.auth.uid &&
                          (
                            // 1. 질문 내용(title, content) 수정
                            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['title', 'content', 'updatedAt']) &&
                             request.resource.data.title is string &&
                             request.resource.data.content is string &&
                             request.resource.data.assignee == resource.data.get('assignee', null) &&
                             request.resource.data.completed == resource.data.completed) ||
                            
                            // 2. 질문자가 메시지 추가/수정/삭제 (answers 배열) - 완료되지 않은 경우만
                            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['answers', 'updatedAt']) &&
                             request.resource.data.title == resource.data.title &&
                             request.resource.data.content == resource.data.content &&
                             request.resource.data.assignee == resource.data.get('assignee', null) &&
                             request.resource.data.completed == resource.data.completed &&
                             request.resource.data.answers is list &&
                             resource.data.completed == false) ||
                            
                            // 3. 질문자가 완료 상태 변경 (답변이 있는 경우에만)
                            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['completed', 'updatedAt']) &&
                             request.resource.data.title == resource.data.title &&
                             request.resource.data.content == resource.data.content &&
                             request.resource.data.assignee == resource.data.get('assignee', null) &&
                             request.resource.data.answers == resource.data.get('answers', []) &&
                             (request.resource.data.completed == false || resource.data.get('answers', []).size() > 0))
                          )) ||
                         
                         // 담당자 권한
                         (resource.data.assignee == request.auth.uid &&
                          (
                            // 1. 답변자가 메시지 추가/수정/삭제 (answers 배열) - 완료되지 않은 경우만
                            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['answers', 'updatedAt']) &&
                             request.resource.data.title == resource.data.title &&
                             request.resource.data.content == resource.data.content &&
                             request.resource.data.assignee == resource.data.assignee &&
                             request.resource.data.completed == resource.data.completed &&
                             request.resource.data.answers is list &&
                             resource.data.completed == false) ||
                            
                            // 2. 답변자가 완료 상태 변경 (답변이 있는 경우에만)
                            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['completed', 'updatedAt']) &&
                             request.resource.data.title == resource.data.title &&
                             request.resource.data.content == resource.data.content &&
                             request.resource.data.assignee == resource.data.assignee &&
                             request.resource.data.answers == resource.data.get('answers', []) &&
                             (request.resource.data.completed == false || resource.data.get('answers', []).size() > 0))
                          ))
                       );
      
      // 삭제 권한: 비활성화 (질문 삭제 불가)
      allow delete: if false;
    }
    
    match /users/{username} {
      allow read, write: if request.auth != null && request.auth.uid == username;
    }
    
    // Helper function to validate that new answers have the correct sender
    function validateAnswerSender(newAnswers, oldAnswers, expectedSender) {
      let newAnswersList = newAnswers;
      let oldAnswersList = oldAnswers;
      return newAnswersList.size() > oldAnswersList.size() &&
             newAnswersList[newAnswersList.size() - 1].sender == expectedSender &&
             newAnswersList[newAnswersList.size() - 1].content is string &&
             newAnswersList[newAnswersList.size() - 1].timestamp is timestamp;
    }
  }
}
